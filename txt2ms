#!/bin/awk -f

# if someone wants to use that:
#   ‥text‥   to print italic
#   ‥‥text‥‥ to print bold
# it might be better to just use \fI and \fB directly
function parsed(a){
	if(dontparse) return a
	gsub(/‥‥[^‥]+‥‥/, "\\fB&\\fR", a)
	gsub(/‥‥/, "", a)
	gsub(/‥[^‥]+‥/, "\\fI&\\fR", a)
	gsub(/‥/, "", a)
	return a
}

BEGIN {
	print ".de XS\n.ds LQ \"\"\n.nr |i (\\\\$1i-1i)/3u\n.ie '\\\\$1'0' .tm .XL \\\\$1 \\\\*(LQ\\\\$2\\\\*(LQ \\\\n%\n.el .tm .XL \\\\$1 \\\\*(LQ\\h'\\\\n(|iu'\\\\*(SN\\0\\0\\\\$2\\\\*(LQ \\\\n%\n.."
	print ".de XL\n.nr |i \\\\$1\n.ta \\\\n(LLuR\n.ie \\\\$1>1 \\\n\\{\\\n\\\\$2 \\a\\|\\|\\\\$3\n.vs 15pt\n.\\}\n.el \\\n\\{\\\n\\fB\\\\$2	\\|\\|\\\\$3\\fR\n.vs 25pt\n.\\}\n.."
}

firstheader && NR == 1 {
	printf ".TL\n%s\n", parsed($0)
	nextline = 1
}

$1 ~ /^#+$/ {
	l = length($1)
	$1 = ""
	sub(/^[ \t]*/, "")
	printf ".NH %d\n.LG\n%s\n.NL\n", l, parsed($0)
	printf ".XS %d \"%s\"\n", l, parsed($0)
	istitle = 1
	nextline = 1
}

$1 ~ /^\$+$/ {
	$1 = ""
	sub(/^[ \t]*/, "")
	printf ".SH\n.LG\n%s\n.NL\n", parsed($0)
	printf ".XS 0 \"%s\"\n", parsed($0)
	istitle = 1
	nextline = 1
}

$1 ~ /^-/ {
	$1 = ""
	sub(/^[ \t]*/, "")
	printf ".IP •\n%s\n", parsed($0)
	nextline = 1
}

/^$/ {
	if(istitle)
		printf ".LP"
	else
		printf ".PP"
	istitle = 0
}

{
	if(nextline == 0)
		print parsed($0)
	else
		nextline = 0
}
